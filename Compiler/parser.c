#include "compiler.h"
/**
 * @brief Parses the tokens generated by the lexer and constructs the abstract tree syntax(AST)
 * 
 * parse - This function takes an array of tokens generated by the lexer and constructs
 * the abstract syntax tree (AST) representing the parsed expression.
 * @tokens - An array of tokens generated by the lexer
 * Return: The root node of the AST.
 * @warning The returned AST must be freed by the caller.
*/
ASTNode* parse(Token *tokens) {
    int index = 0;
    Token token = tokens[index++]; //Get the first token

    // Enusre that the token stream is not empty
    if (token.type == TOKEN_END) {
        fprintf(stderr, "Empty token stream\n");
        exit(EXIT_FAILURE);
    }

    // Create a root node for the AST
    ASTNode *root = malloc(sizeof(ASTNode));
    if (root == NULL) {
        fprintf(stderr, "Memory allocation failed\n");
        exit(EXIT_FAILURE);
    }

    //parse the expression
    if (token.type == TOKEN_NUMBER) {
    root->type = NODE_NUMBER; //Assume the first token is always a number
    root->value = token.value;
    }
    else {
        fprintf(stderr, "Expected number or '(' at the beginning of the expression\n");
        exit(EXIT_FAILURE);
    }

    //continue parsing until we reach the end of the token array
    while (token.type != TOKEN_END) {
        token = tokens[index++];

        //create a new node for the operator
        ASTNode *operator_node = malloc(sizeof(ASTNode));
        if (operator_node == NULL) {
            fprintf(stderr, "Memory allocation failed\n");
            exit(EXIT_FAILURE);
        }

        // Set the operator type based on the token type
        if (token.type == TOKEN_PLUS) {
            operator_node->type = NODE_ADD;
        }
        else if (token.type == TOKEN_MINUS) {
            operator_node->type = NODE_SUBTRACT;
        }
        else if (token.type == TOKEN_MULTIPLY) {
            operator_node->type = NODE_MULTIPLY;
        }
        else if (token.type == TOKEN_DIVIDE) {
            operator_node->type = NODE_DIVIDE;
        }
        else {
            fprintf(stderr, "Unexpected token\n");
            exit(EXIT_FAILURE);
        }

        // Set the left and right children of the operator node
        operator_node->left = root;
        operator_node->right = malloc(sizeof(ASTNode));
        if (operator_node->right == NULL) {
            fprintf(stderr, "Memory allocation failed\n");
            exit(EXIT_FAILURE);
        }

        //Get the next token (which should be a number)
        token = tokens[index++];
        if (token.type != TOKEN_NUMBER) {
            fprintf(stderr, "Expected number\n");
            exit(EXIT_FAILURE);
        }

        // Create a new node for the number
        operator_node->right->type = NODE_NUMBER;
        operator_node->right->value = token.value;

        // The new root becomes the operator node
        root = operator_node;
    }
    return root;
}

/**
 * free_ast - Frees the meoemry allocated for the Abstract Syntax Tree(AST)
 * @node - The root node of the ASR to free
 * Return: Nothing
*/
void free_ast(ASTNode *node) {
    if (node != NULL) {
        if (node->type == NODE_BINARY_OPERATION) {
            free_ast(node->left);
            free_ast(node->right);
        }
        free(node);
    }
}
